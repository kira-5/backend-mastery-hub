# 🧰 Data Structures

* * *

## 📝 Strings

* * *

## 📦 Arrays

* * *

## 📚 Vectors

* * *

## 🔗 Tuples

* * *

## 🗝️ HashMaps

* * *

## 🎯 HashSets

* * *

## 🏗️ Structs

* * *

## 🎲 Enums

* * *

## Array vs Vector

### Array vs Vector Differences

- **Array**: Fixed-size collection of same-type elements
- **Vector**: Growable collection of same-type elements

### Array vs Vector Comparison

| Feature     | Array                                  | Vector                              |
|------------|----------------------------------------|-------------------------------------|
| Size       | Fixed at compile time                  | Growable at runtime                 |
| Memory     | Stack-allocated (small arrays)         | Heap-allocated                      |
| Flexibility| Rigid — compile-time size/type         | Flexible — runtime size changes     |
| Use Case   | Known, constant size                   | Dynamic or unknown size             |

> 💡 **Pro Tip**: Arrays can be heap-allocated using `Box<[T; N]>`, but stack allocation is more common.

## 🔑 HashMap vs HashSet

### HashMap vs HashSet Differences

- **HashMap**: Key-value pair collection
- **HashSet**: Unique value collection

### HashMap vs HashSet Comparison

| Feature   | HashMap                          | HashSet                             |
|-----------|----------------------------------|-------------------------------------|
| Structure | ✔️ Key-Value pairs                | ✔️ Unique values only                |
| Storage   | ✔️ Heap-allocated                 | ✔️ Heap-allocated                    |
| Ordering  | ✔️ Unordered                      | ✔️ Unordered                         |
| Use Case  | ✔️ Key-value mapping              | ✔️ Unique values storage             |

> 💡 **Pro Tip**: Both HashMap and HashSet are heap-allocated for dynamic memory management.

* * *

## ⏱️ Time Complexity Analysis

### String Operations

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Insert (end) | O(1) | Amortized, because it's backed by a `Vec<u8>` |
| Insert (start/middle) | O(n) | Requires shifting |
| Delete | O(n) | UTF-8 validation |
| Search | O(n) | Pattern matching |

### Array Operations

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Insert | O(n) | Cannot "insert" in-place; emulate with copy |
| Delete | O(n) | Shifting required / cannot resize |
| Search | O(n) | Linear scan |

### Vector Operations

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Insert (end) | O(1) | Amortized |
| Insert (start/middle) | O(n) | Shifting required |
| Delete (end) | O(1) | Direct removal |
| Delete (start/middle) | O(n) | Shifting required |
| Search | O(n) | Linear scan |

### Tuple Operations

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Access | O(1) | Compile-time index |

> 🧠 **Memory Note**: No dynamic insertion/deletion/search in tuples.

### HashMap Operations

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Insert | O(1) avg, O(n) worst | Collision dependent |
| Delete | O(1) avg | Amortized |
| Search | O(1) avg, O(n) worst | Collision dependent |

### HashSet Operations

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Insert | O(1) avg | Average case |
| Delete | O(1) avg | Average case |
| Search | O(1) avg | Average case |

* * *

## 💡 Performance Optimization Tips

> 🧠 **Pro Tip**: Choose data structures based on your access patterns:
>
> - Use `Vec<T>` for fast push/pop operations
> - Use `HashMap<K, V>` for fast key-value lookups
> - Prefer `&str` over `String` when mutation isn't needed
