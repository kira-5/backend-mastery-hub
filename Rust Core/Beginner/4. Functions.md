# Functions

## fn Keyword

-   The main function is the entry point of a Rust program.

**Declaration:**

```rust
fn main() {
    println!("Hello from main!");
}
```

## Parameters

-   Functions can take parameters with explicit types.
-   You can return values using -> Type and either the return keyword or just the final expression (no semicolon).

**Declaration:**

```rust
fn greet(name: &str) {
    println!("Hello, {}!", name);
}

fn add(x: i32, y: i32) -> i32 {
    x + y // no semicolon = return
}

fn main() {
    greet("Rustacean");
    let result = add(3, 4);
    println!("Sum is: {}", result);
}
```

## Expressions vs Statements

-   Rust functions are expression-based.
-   The last line in a function (without a semicolon) is returned automatically.

**Declaration:**

```Rust
fn square(x: i32) -> i32 {
    x * x // expression (no semicolon)
}

fn main() {
    let result = square(5);
    println!("Result is: {}", result);
}
```

## Function with Multiple Returns (Tuple)

-   Functions with Multiple Return Values (Tuple)

**Declaration:**

```Rust
fn divide(x: f64, y: f64) -> (f64, f64) {
    (x / y, x % y)
}

fn make_multiplier(multiplier: i32) -> impl Fn(i32) -> i32 {
    move |x| x * multiplier
}

fn main() {
    let multiply_by_2 = make_multiplier(2);
    let multiply_by_3 = make_multiplier(3);

    println!("Multiply by 2: {}", multiply_by_2(5));
    println!("Multiply by 3: {}", multiply_by_3(5));
}
```

## Default Parameters (Note ðŸš«: Not supported directly)

-   Rust does **not** support default parameters natively like some other languages (e.g., Python). You can simulate this with **function overloading via optional wrapping** or **custom logic**.

**Declaration:**

```rust
fn greet(name: &str, age: Option<u8>) {
    let age = age.unwrap_or(1); // default age is 1
    println!("Hello, {}! You are {} years old.", name, age);
}

fn main() {
    greet("Rustacean", Some(2));
    greet("Ferris", None);
}
```

## Closures

-   Closures are anonymous functions.
-   They can capture variables from their environment.
-   Closures can capture environment variables and infer parameter/return types.

**Declaration:**

```rust
fn main() {
    let add = |x: i32, y: i32| x + y;

    let result = add(3, 4);
    println!("Sum is: {}", result);
}
```

## Higher-Order Functions

-   Higher-order functions are functions that can take other functions as parameters or return a function.

**Declaration:**

```rust
fn apply_function(f: fn(i32) -> i32, x: i32) -> i32 {
    f(x)
}

fn square(x: i32) -> i32 {
    x * x
}

fn main() {
    let result = apply_function(square, 5);
    println!("Result is: {}", result);
}
```

## Recursion

-   Recursion is the process of a function calling itself.

**Declaration:**

```rust
fn factorial(n: u32) -> u32 {
    if n == 0 {
        return 1;
    }
    n * factorial(n - 1)
}

fn main() {
    let result = factorial(5);
    println!("Factorial is: {}", result);
}
```

## Function Pointers

-   Function pointers are pointers to functions.

**Declaration:**

```rust
fn add(x: i32, y: i32) -> i32 {
    x + y
}

fn main() {
    let add_ptr: fn(i32, i32) -> i32 = add;
    let result = add_ptr(3, 4);
    println!("Sum is: {}", result);
}
```
